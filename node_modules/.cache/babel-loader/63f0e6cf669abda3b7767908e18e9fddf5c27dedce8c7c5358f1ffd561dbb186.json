{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"FEATURES\", {\n  enumerable: true,\n  get: function () {\n    return _features.FEATURES;\n  }\n});\nObject.defineProperty(exports, \"buildCheckInRHS\", {\n  enumerable: true,\n  get: function () {\n    return _fields.buildCheckInRHS;\n  }\n});\nexports.createClassFeaturePlugin = createClassFeaturePlugin;\nObject.defineProperty(exports, \"enableFeature\", {\n  enumerable: true,\n  get: function () {\n    return _features.enableFeature;\n  }\n});\nObject.defineProperty(exports, \"injectInitialization\", {\n  enumerable: true,\n  get: function () {\n    return _misc.injectInitialization;\n  }\n});\nvar _core = require(\"@babel/core\");\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\nvar _semver = require(\"semver\");\nvar _fields = require(\"./fields.js\");\nvar _decorators = require(\"./decorators.js\");\nvar _misc = require(\"./misc.js\");\nvar _features = require(\"./features.js\");\nvar _typescript = require(\"./typescript.js\");\nconst versionKey = \"@babel/plugin-class-features/version\";\nfunction createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions,\n  api,\n  inherits\n}) {\n  {\n    var _api;\n    (_api = api) != null ? _api : api = {\n      assumption: () => void 0\n    };\n  }\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsSymbols = api.assumption(\"privateFieldsAsSymbols\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n  if (privateFieldsAsProperties && privateFieldsAsSymbols) {\n    throw new Error(`Cannot enable both the \"privateFieldsAsProperties\" and ` + `\"privateFieldsAsSymbols\" assumptions as the same time.`);\n  }\n  const privateFieldsAsSymbolsOrProperties = privateFieldsAsProperties || privateFieldsAsSymbols;\n  if (loose === true) {\n    const explicit = [];\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n    if (privateFieldsAsSymbols !== undefined) {\n      explicit.push(`\"privateFieldsAsSymbols\"`);\n    }\n    if (explicit.length !== 0) {\n      console.warn(`[${name}]: You are using the \"loose: true\" option and you are` + ` explicitly setting a value for the ${explicit.join(\" and \")}` + ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` + ` can cause incompatibilities with the other class features` + ` plugins, so it's recommended that you replace it with the` + ` following top-level option:\\n` + `\\t\"assumptions\": {\\n` + `\\t\\t\"setPublicClassFields\": true,\\n` + `\\t\\t\"privateFieldsAsSymbols\": true\\n` + `\\t}`);\n    }\n  }\n  return {\n    name,\n    manipulateOptions,\n    inherits,\n    pre(file) {\n      (0, _features.enableFeature)(file, feature, loose);\n      {\n        if (typeof file.get(versionKey) === \"number\") {\n          file.set(versionKey, \"7.22.15\");\n          return;\n        }\n      }\n      if (!file.get(versionKey) || _semver.lt(file.get(versionKey), \"7.22.15\")) {\n        file.set(versionKey, \"7.22.15\");\n      }\n    },\n    visitor: {\n      Class(path, {\n        file\n      }) {\n        var _ref;\n        if (file.get(versionKey) !== \"7.22.15\") return;\n        if (!(0, _features.shouldTransform)(path, file)) return;\n        const pathIsClassDeclaration = path.isClassDeclaration();\n        if (pathIsClassDeclaration) (0, _typescript.assertFieldTransformed)(path);\n        const loose = (0, _features.isLoose)(file, feature);\n        let constructor;\n        const isDecorated = (0, _decorators.hasDecorators)(path.node);\n        const props = [];\n        const elements = [];\n        const computedPaths = [];\n        const privateNames = new Set();\n        const body = path.get(\"body\");\n        for (const path of body.get(\"body\")) {\n          if ((path.isClassProperty() || path.isClassMethod()) && path.node.computed) {\n            computedPaths.push(path);\n          }\n          if (path.isPrivate()) {\n            const {\n              name\n            } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n            if (path.isClassPrivateMethod()) {\n              if (path.node.kind === \"get\") {\n                if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(getName).add(name);\n              } else if (path.node.kind === \"set\") {\n                if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(setName).add(name);\n              }\n            } else {\n              if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n              privateNames.add(name);\n            }\n          }\n          if (path.isClassMethod({\n            kind: \"constructor\"\n          })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n            if (path.isProperty() || path.isPrivate() || path.isStaticBlock != null && path.isStaticBlock()) {\n              props.push(path);\n            }\n          }\n        }\n        {\n          if (!props.length && !isDecorated) return;\n        }\n        const innerBinding = path.node.id;\n        let ref;\n        if (!innerBinding || !pathIsClassDeclaration) {\n          (0, _helperFunctionName.default)(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        }\n        const classRefForDefine = (_ref = ref) != null ? _ref : _core.types.cloneNode(innerBinding);\n        const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props);\n        const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, privateFieldsAsSymbols != null ? privateFieldsAsSymbols : false, file);\n        (0, _fields.transformPrivateNamesUsage)(classRefForDefine, path, privateNamesMap, {\n          privateFieldsAsProperties: privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose,\n          noDocumentAll,\n          innerBinding\n        }, file);\n        let keysNodes, staticNodes, instanceNodes, pureStaticNodes, classBindingNode, wrapClass;\n        {\n          if (isDecorated) {\n            staticNodes = pureStaticNodes = keysNodes = [];\n            ({\n              instanceNodes,\n              wrapClass\n            } = (0, _decorators.buildDecoratedClass)(classRefForDefine, path, elements, file));\n          } else {\n            keysNodes = (0, _misc.extractComputedKeys)(path, computedPaths, file);\n            ({\n              staticNodes,\n              pureStaticNodes,\n              instanceNodes,\n              classBindingNode,\n              wrapClass\n            } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, file, setPublicClassFields != null ? setPublicClassFields : loose, privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose, constantSuper != null ? constantSuper : loose, innerBinding));\n          }\n        }\n        if (instanceNodes.length > 0) {\n          (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {\n            {\n              if (isDecorated) return;\n            }\n            for (const prop of props) {\n              if (_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node) || prop.node.static) continue;\n              prop.traverse(referenceVisitor, state);\n            }\n          });\n        }\n        const wrappedPath = wrapClass(path);\n        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);\n        if (staticNodes.length > 0) {\n          wrappedPath.insertAfter(staticNodes);\n        }\n        if (pureStaticNodes.length > 0) {\n          wrappedPath.find(parent => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);\n        }\n        if (classBindingNode != null && pathIsClassDeclaration) {\n          wrappedPath.insertAfter(classBindingNode);\n        }\n      },\n      ExportDefaultDeclaration(path, {\n        file\n      }) {\n        {\n          if (file.get(versionKey) !== \"7.22.15\") return;\n          const decl = path.get(\"declaration\");\n          if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {\n            if (decl.node.id) {\n              (0, _helperSplitExportDeclaration.default)(path);\n            } else {\n              decl.node.type = \"ClassExpression\";\n            }\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["_core","require","_helperFunctionName","_helperSplitExportDeclaration","_semver","_fields","_decorators","_misc","_features","_typescript","versionKey","createClassFeaturePlugin","name","feature","loose","manipulateOptions","api","inherits","_api","assumption","setPublicClassFields","privateFieldsAsSymbols","privateFieldsAsProperties","constantSuper","noDocumentAll","Error","privateFieldsAsSymbolsOrProperties","explicit","undefined","push","length","console","warn","join","pre","file","enableFeature","get","set","lt","visitor","Class","path","_ref","shouldTransform","pathIsClassDeclaration","isClassDeclaration","assertFieldTransformed","isLoose","constructor","isDecorated","hasDecorators","node","props","elements","computedPaths","privateNames","Set","body","isClassProperty","isClassMethod","computed","isPrivate","key","id","getName","setName","isClassPrivateMethod","kind","has","buildCodeFrameError","add","isProperty","isStaticBlock","innerBinding","ref","default","scope","generateUidIdentifier","classRefForDefine","types","cloneNode","privateNamesMap","buildPrivateNamesMap","privateNamesNodes","buildPrivateNamesNodes","transformPrivateNamesUsage","keysNodes","staticNodes","instanceNodes","pureStaticNodes","classBindingNode","wrapClass","buildDecoratedClass","extractComputedKeys","buildFieldsInitNodes","superClass","injectInitialization","referenceVisitor","state","prop","static","traverse","wrappedPath","insertBefore","insertAfter","find","parent","isStatement","isDeclaration","ExportDefaultDeclaration","decl","type"],"sources":["D:\\Codes\\Web Development\\FCS project\\FCS project\\fcsproject\\node_modules\\@babel\\helper-create-class-features-plugin\\src\\index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { PluginAPI, PluginObject } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\n\nimport semver from \"semver\";\n\nimport {\n  buildPrivateNamesNodes,\n  buildPrivateNamesMap,\n  transformPrivateNamesUsage,\n  buildFieldsInitNodes,\n  buildCheckInRHS,\n} from \"./fields.ts\";\nimport type { PropPath } from \"./fields.ts\";\nimport { buildDecoratedClass, hasDecorators } from \"./decorators.ts\";\nimport { injectInitialization, extractComputedKeys } from \"./misc.ts\";\nimport {\n  enableFeature,\n  FEATURES,\n  isLoose,\n  shouldTransform,\n} from \"./features.ts\";\nimport { assertFieldTransformed } from \"./typescript.ts\";\n\nexport { FEATURES, enableFeature, injectInitialization, buildCheckInRHS };\n\nconst versionKey = \"@babel/plugin-class-features/version\";\n\ninterface Options {\n  name: string;\n  feature: number;\n  loose?: boolean;\n  inherits?: PluginObject[\"inherits\"];\n  manipulateOptions?: PluginObject[\"manipulateOptions\"];\n  api?: PluginAPI;\n}\n\nexport function createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions,\n  api,\n  inherits,\n}: Options): PluginObject {\n  if (!process.env.BABEL_8_BREAKING) {\n    api ??= { assumption: () => void 0 as any } as any;\n  }\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsSymbols = api.assumption(\"privateFieldsAsSymbols\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n\n  if (privateFieldsAsProperties && privateFieldsAsSymbols) {\n    throw new Error(\n      `Cannot enable both the \"privateFieldsAsProperties\" and ` +\n        `\"privateFieldsAsSymbols\" assumptions as the same time.`,\n    );\n  }\n  const privateFieldsAsSymbolsOrProperties =\n    privateFieldsAsProperties || privateFieldsAsSymbols;\n\n  if (loose === true) {\n    type AssumptionName = Parameters<PluginAPI[\"assumption\"]>[0];\n    const explicit: `\"${AssumptionName}\"`[] = [];\n\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n    if (privateFieldsAsSymbols !== undefined) {\n      explicit.push(`\"privateFieldsAsSymbols\"`);\n    }\n    if (explicit.length !== 0) {\n      console.warn(\n        `[${name}]: You are using the \"loose: true\" option and you are` +\n          ` explicitly setting a value for the ${explicit.join(\" and \")}` +\n          ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` +\n          ` can cause incompatibilities with the other class features` +\n          ` plugins, so it's recommended that you replace it with the` +\n          ` following top-level option:\\n` +\n          `\\t\"assumptions\": {\\n` +\n          `\\t\\t\"setPublicClassFields\": true,\\n` +\n          `\\t\\t\"privateFieldsAsSymbols\": true\\n` +\n          `\\t}`,\n      );\n    }\n  }\n\n  return {\n    name,\n    manipulateOptions,\n    inherits,\n\n    pre(file) {\n      enableFeature(file, feature, loose);\n\n      if (!process.env.BABEL_8_BREAKING) {\n        // Until 7.21.4, we used to encode the version as a number.\n        // If file.get(versionKey) is a number, it has thus been\n        // set by an older version of this plugin.\n        if (typeof file.get(versionKey) === \"number\") {\n          file.set(versionKey, PACKAGE_JSON.version);\n          return;\n        }\n      }\n      if (\n        !file.get(versionKey) ||\n        semver.lt(file.get(versionKey), PACKAGE_JSON.version)\n      ) {\n        file.set(versionKey, PACKAGE_JSON.version);\n      }\n    },\n\n    visitor: {\n      Class(path, { file }) {\n        if (file.get(versionKey) !== PACKAGE_JSON.version) return;\n\n        if (!shouldTransform(path, file)) return;\n\n        const pathIsClassDeclaration = path.isClassDeclaration();\n\n        if (pathIsClassDeclaration) assertFieldTransformed(path);\n\n        const loose = isLoose(file, feature);\n\n        let constructor: NodePath<t.ClassMethod>;\n        const isDecorated = hasDecorators(path.node);\n        const props: PropPath[] = [];\n        const elements = [];\n        const computedPaths: NodePath<t.ClassProperty | t.ClassMethod>[] = [];\n        const privateNames = new Set<string>();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          if (\n            // check path.node.computed is enough, but ts will complain\n            (path.isClassProperty() || path.isClassMethod()) &&\n            path.node.computed\n          ) {\n            computedPaths.push(path);\n          }\n\n          if (path.isPrivate()) {\n            const { name } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n\n            if (path.isClassPrivateMethod()) {\n              if (path.node.kind === \"get\") {\n                if (\n                  privateNames.has(getName) ||\n                  (privateNames.has(name) && !privateNames.has(setName))\n                ) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(getName).add(name);\n              } else if (path.node.kind === \"set\") {\n                if (\n                  privateNames.has(setName) ||\n                  (privateNames.has(name) && !privateNames.has(getName))\n                ) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(setName).add(name);\n              }\n            } else {\n              if (\n                (privateNames.has(name) &&\n                  !privateNames.has(getName) &&\n                  !privateNames.has(setName)) ||\n                (privateNames.has(name) &&\n                  (privateNames.has(getName) || privateNames.has(setName)))\n              ) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(name);\n            }\n          }\n\n          if (path.isClassMethod({ kind: \"constructor\" })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n            if (\n              path.isProperty() ||\n              path.isPrivate() ||\n              path.isStaticBlock?.()\n            ) {\n              props.push(path as PropPath);\n            }\n          }\n        }\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (!props.length) return;\n        } else {\n          if (!props.length && !isDecorated) return;\n        }\n\n        const innerBinding = path.node.id;\n        let ref: t.Identifier | null;\n        if (!innerBinding || !pathIsClassDeclaration) {\n          nameFunction(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        }\n        const classRefForDefine = ref ?? t.cloneNode(innerBinding);\n\n        // NODE: These three functions don't support decorators yet,\n        //       but verifyUsedFeatures throws if there are both\n        //       decorators and private fields.\n        const privateNamesMap = buildPrivateNamesMap(props);\n        const privateNamesNodes = buildPrivateNamesNodes(\n          privateNamesMap,\n          privateFieldsAsProperties ?? loose,\n          privateFieldsAsSymbols ?? false,\n          file,\n        );\n\n        transformPrivateNamesUsage(\n          classRefForDefine,\n          path,\n          privateNamesMap,\n          {\n            privateFieldsAsProperties:\n              privateFieldsAsSymbolsOrProperties ?? loose,\n            noDocumentAll,\n            innerBinding,\n          },\n          file,\n        );\n\n        let keysNodes: t.Statement[],\n          staticNodes: t.Statement[],\n          instanceNodes: t.Statement[],\n          pureStaticNodes: t.FunctionDeclaration[],\n          classBindingNode: t.Statement | null,\n          wrapClass: (path: NodePath<t.Class>) => NodePath;\n\n        if (!process.env.BABEL_8_BREAKING) {\n          if (isDecorated) {\n            staticNodes = pureStaticNodes = keysNodes = [];\n            ({ instanceNodes, wrapClass } = buildDecoratedClass(\n              classRefForDefine,\n              path,\n              elements,\n              file,\n            ));\n          } else {\n            keysNodes = extractComputedKeys(path, computedPaths, file);\n            ({\n              staticNodes,\n              pureStaticNodes,\n              instanceNodes,\n              classBindingNode,\n              wrapClass,\n            } = buildFieldsInitNodes(\n              ref,\n              path.node.superClass,\n              props,\n              privateNamesMap,\n              file,\n              setPublicClassFields ?? loose,\n              privateFieldsAsSymbolsOrProperties ?? loose,\n              constantSuper ?? loose,\n              innerBinding,\n            ));\n          }\n        } else {\n          keysNodes = extractComputedKeys(path, computedPaths, file);\n          ({\n            staticNodes,\n            pureStaticNodes,\n            instanceNodes,\n            classBindingNode,\n            wrapClass,\n          } = buildFieldsInitNodes(\n            ref,\n            path.node.superClass,\n            props,\n            privateNamesMap,\n            file,\n            setPublicClassFields ?? loose,\n            privateFieldsAsSymbolsOrProperties ?? loose,\n            constantSuper ?? loose,\n            innerBinding,\n          ));\n        }\n\n        if (instanceNodes.length > 0) {\n          injectInitialization(\n            path,\n            constructor,\n            instanceNodes,\n            (referenceVisitor, state) => {\n              if (!process.env.BABEL_8_BREAKING) {\n                if (isDecorated) return;\n              }\n              for (const prop of props) {\n                // @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock\n                if (t.isStaticBlock?.(prop.node) || prop.node.static) continue;\n                prop.traverse(referenceVisitor, state);\n              }\n            },\n          );\n        }\n\n        // rename to make ts happy\n        const wrappedPath = wrapClass(path);\n        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);\n        if (staticNodes.length > 0) {\n          wrappedPath.insertAfter(staticNodes);\n        }\n        if (pureStaticNodes.length > 0) {\n          wrappedPath\n            .find(parent => parent.isStatement() || parent.isDeclaration())\n            .insertAfter(pureStaticNodes);\n        }\n        if (classBindingNode != null && pathIsClassDeclaration) {\n          wrappedPath.insertAfter(classBindingNode);\n        }\n      },\n\n      ExportDefaultDeclaration(path, { file }) {\n        if (!process.env.BABEL_8_BREAKING) {\n          if (file.get(versionKey) !== PACKAGE_JSON.version) return;\n\n          const decl = path.get(\"declaration\");\n\n          if (decl.isClassDeclaration() && hasDecorators(decl.node)) {\n            if (decl.node.id) {\n              // export default class Foo {}\n              //   -->\n              // class Foo {} export { Foo as default }\n              splitExportDeclaration(path);\n            } else {\n              // @ts-expect-error Anonymous class declarations can be\n              // transformed as if they were expressions\n              decl.node.type = \"ClassExpression\";\n            }\n          }\n        }\n      },\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}